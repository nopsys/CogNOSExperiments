## This file defines common functions used for data processing.
load_metrics_file <- function(benchmark_name, iter, data_set) {
  filename <- paste0("/../Data/Metrics/", benchmark_name, "-", iter, "/", data_set, ".csv")
  read.table(filename, sep="\t", header=TRUE, fill=TRUE, comment.char = "")
}

load_data_file <- function (file, row_names) {
  if (missing(row_names)) {
    # these row names are hard coded and might not be applicable
    # names like this are generated by ReBench
    row_names <- c("TimeStamp", "Value", "Unit", "Criterion", "Benchmark",
                   "VM", "Suite", "Extra", "Warmup", "Cores", "InputSize",
                   "Var")
  }
  
  bench <- read.table(file, sep="\t", header=FALSE, col.names=row_names, fill=TRUE)
  bench$rid = seq_len(nrow(bench))
  bench <- ddply(bench, ~ Benchmark + VM + Var + Extra + Cores + Suite, transform,
                 Iteration = rid - min(rid))
  
  bench
}

getAndPrepareData <- function(filename, filterColumns) {
  data <- load_data_file(filename)
  if (!missing(filterColumns)) {
    data <- subset(data, select=filterColumns)
  }
  data
}

change_names <- function(data, name_map, column) {
  levels(data[,column])  <- map_names(
    levels(data[,column]),
    name_map)
  data
}

map_names <- function(old_names, name_map) {
  for (i in 1:length(old_names)) {
    old_name <- old_names[[i]]
    if (old_name %in% names(name_map)) {
      old_names[i] <- name_map[[old_name]]
    }
  }
  old_names
}

vmNamesMap <- function() {
  name_map <-     list("Java8U66"              = "Java, 1.8.0_66",
                       #                       "JRubyJ8"               = "Ruby, JRuby 9.0.4.0 + indy", #invokedynamic
                       #                       "MRI22"                 = "Ruby, MRI 2.2",
                       #                       "MRI23"                 = "Ruby, MRI 2.3",
                       #                       "RBX314"                = "Ruby, Rubinius 3.14",
                       #                       "GraalJS"               = "JavaScript, GraalJS",
                                               "Node"                  = "Node.js",
                       #                       "SOMns"                 = "SOMns, Newspeak, master",
                       #                       "SOMns-Enterprise"      = "SOMns, Newspeak",
                       #                       "JRubyTruffle"          = "Ruby, JRuby+Truffle, truffle head (basic)",
                       #                       "JRubyTruffleEnterprise" = "Ruby, JRuby+Truffle", # , truffle head
                       
                       "TruffleSOM-graal"                      = "SOMpe",
                       "TruffleMate-graal"                     = "MATEpe",
                       "RTruffleSOM"                           = "SOMmt",
                       "RTruffleMate"                          = "MATEmt",
                       "RTruffleMate-envInObj"                 = "MATEmt-envInObj",
                       "TruffleSOM-graal-enterprise"           = "SOMpe",
                       "TruffleMate-graal-enterprise"          = "MATEpe",
                       "TruffleMate-graal-enterprise-naive"    = "MATEpe-NoOpt",
                       "TruffleMate-graal-enterprise-envInObj" = "MATEpe-envInObj",
                       "Pharo"                  = "Pharo")
  #                       "TruffleSOM-graal-no-split" = "TruffleSOM.ns",
  #                       "SOMpp"                 = "SOM++")
  # Rename
  name_map
}

getRawData <- function(filename, filterColumns, vmNames, keepVMs, maxIteration = 0) {
  data <- getAndPrepareData(filename, filterColumns)
  data <- change_names(data, vmNames, "VM")
  data <- droplevels(subset(data, VM %in% keepVMs))  
  if (maxIteration != 0){
    data <- droplevels(subset(data, Iteration <= maxIteration))  
  }
  return(data)
}

getFilteredData <- function(filename, filterColumns, vmNames, keepVms, iterationsFilename, iterationsColNames, numberOfIterations) {
  data <- getRawData(filename, filterColumns, vmNames, keepVms)
  steady <- selectIterationsAndInlining(data, iterationsFilename, iterationsColNames, numberOfIterations)
  steady
}

getWarmedupData <- function(filename, filterColumns, vmNames, keepVms, numberOfIterations) {
  data <- getRawData(filename, filterColumns, vmNames, keepVms)
  steady <- selectWarmedupData(data, numberOfIterations)
  steady
}

getWarmupData <- function(filename, filterColumns, vmNames, keepVms, numberOfIterations) {
  data <- getRawData(filename, filterColumns, vmNames, keepVms)
  steady <- selectWarmupData(data, numberOfIterations)
  steady
}

selectWarmedupData <- function(data, numberOfIterations) {
  return (selectData(data, numberOfIterations, TRUE))
}

selectWarmupData <- function(data, numberOfIterations) {
  return (selectData(data, 0, FALSE))
}

selectData <- function(data, numberOfIterations, warmedup) {
  resultSet <- data
  for (vm in unique(data$VM)){
    filename <- paste("../Warmups/", warmupFilename(vm), sep="")
    warmups <- read.delim(paste("../Warmups/", warmupFilename(vm), sep=""), header = FALSE, skip=0)
    for (b in unique(data$Benchmark)) {
      row <- warmups[warmups$V1 == b,]
      if (nrow(row) == 0) {
        if (b != "CD"){
          "This because CD do not run in Pharo"
          print ("Benchmark removed because there is no row for it in the changepoint file")
          print (b)
          print (vm)
          resultSet <- droplevels(subset(resultSet, Benchmark != b))
        }
      } else {
        realValues <- suppressWarnings(as.numeric(row))
        realValues <- realValues[!is.na(row)]
        realValues <- realValues[realValues != '']
        warmup <- tail(realValues, n=1)
        if (warmup != -1){
          if (warmedup){
            resultSet <- droplevels(subset(resultSet,(
              (Benchmark != b) | (VM != vm) |
                (Benchmark == b & VM == vm & Iteration >= warmup + 3 & Iteration < warmup + numberOfIterations))))
          } else {
            resultSet <- droplevels(subset(resultSet,(
              (Benchmark != b) | (VM != vm) |
                (Benchmark == b & VM == vm & Iteration <= warmup + 2))))
          }
        } else {
          #No automatic warmup. Look for a manual one.
          warmupsManual <- read.delim(paste("../Warmups/", "changePoint-manual.tsv", sep=""), sep="\t", header = FALSE, skip=2)
          row <- warmupsManual[warmupsManual$V1 == vm & warmupsManual$V2 == b,]
          if (nrow(row) == 0) {
            print (paste(paste("Missing manual warmup value for", vm), b))  
          } else {
            warmup <- suppressWarnings(tail(as.numeric(row), n=1))
            if (warmedup){
              resultSet <- droplevels(subset(resultSet,(
                (Benchmark != b) | (VM != vm) |
                  (Benchmark == b & (VM == vm) & Iteration >= warmup + 3 & Iteration < warmup + numberOfIterations))))
            } else {
              resultSet <- droplevels(subset(resultSet,(
                (Benchmark != b) | (VM != vm) |
                  (Benchmark == b & (VM == vm) & Iteration <= warmup + 2))))
            }
          }  
        }
      }
    }
  }
  return (resultSet)
}


microBenchmarks <- c("Bounce", "List", "Mandelbrot", "NBody", "Permute", "Queens", "Sieve", "Storage", "Towers", "Fibonacci", "Recurse")
macroBenchmarks <- c("CD", "DeltaBlue", "Havlak", "Json", "Richards")

mtVMs <- c("SOMmt", "MATEmt", "MATEmt-envInObj")
peVMs <- c("SOMpe", "SOMpe-Ent", "MATEpe", "MATEpe-envInObj")

tracingBenchmarks <- c("QuickSort", "NBody", "DeltaBlue", "JsonBig")